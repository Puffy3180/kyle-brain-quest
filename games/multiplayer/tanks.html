<!DOCTYPE html>
<html>
<head>
    <title>Cyber Tanks (2P)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: 'Space Grotesk', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        canvas { background: #1a1a1a; box-shadow: 0 0 20px #000; }
        .ui { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 50px; font-size: 1.5rem; pointer-events: none; }
        .back-btn { position: absolute; bottom: 20px; color: #555; text-decoration: none; pointer-events: auto; }
    </style>
</head>
<body>
    <div class="ui">
        <div style="color: #00ff00">P1: WASD + SPACE</div>
        <div style="color: #00ffff">P2: ARROWS + ENTER</div>
    </div>
    
    <canvas id="game" width="800" height="600"></canvas>
    
    <a href="../../index.html" class="back-btn">Exit Battle</a>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Input
        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Game State
        const obstacles = [
            {x: 100, y: 100, w: 50, h: 400},
            {x: 650, y: 100, w: 50, h: 400},
            {x: 300, y: 250, w: 200, h: 100}
        ];

        class Tank {
            constructor(x, y, color, controls) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.color = color;
                this.controls = controls;
                this.bullets = [];
                this.cooldown = 0;
                this.score = 0;
                this.alive = true;
                this.respawnTimer = 0;
            }

            update() {
                if (!this.alive) {
                    this.respawnTimer--;
                    if (this.respawnTimer <= 0) this.respawn();
                    return;
                }

                // Move
                const speed = 3;
                if (keys[this.controls.up]) {
                    this.x += Math.cos(this.angle) * speed;
                    this.y += Math.sin(this.angle) * speed;
                }
                if (keys[this.controls.down]) {
                    this.x -= Math.cos(this.angle) * speed;
                    this.y -= Math.sin(this.angle) * speed;
                }
                if (keys[this.controls.left]) this.angle -= 0.05;
                if (keys[this.controls.right]) this.angle += 0.05;

                // Wall/Obstacle Collision
                this.checkCollision();

                // Shoot
                if (this.cooldown > 0) this.cooldown--;
                if (keys[this.controls.shoot] && this.cooldown <= 0) {
                    this.bullets.push({
                        x: this.x + Math.cos(this.angle) * 20,
                        y: this.y + Math.sin(this.angle) * 20,
                        dx: Math.cos(this.angle) * 8,
                        dy: Math.sin(this.angle) * 8,
                        life: 100
                    });
                    this.cooldown = 20;
                }

                // Bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    let b = this.bullets[i];
                    b.x += b.dx;
                    b.y += b.dy;
                    b.life--;

                    // Bounce off walls
                    if (b.x < 0 || b.x > canvas.width) { b.dx *= -1; b.life -= 10; }
                    if (b.y < 0 || b.y > canvas.height) { b.dy *= -1; b.life -= 10; }

                    // Obstacle bounce
                    for (let o of obstacles) {
                        if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) {
                            b.dx *= -1; b.dy *= -1;
                            b.life -= 10;
                        }
                    }

                    if (b.life <= 0) this.bullets.splice(i, 1);
                }
            }

            checkCollision() {
                // Bounds
                this.x = Math.max(15, Math.min(canvas.width - 15, this.x));
                this.y = Math.max(15, Math.min(canvas.height - 15, this.y));

                // Obstacles
                for (let o of obstacles) {
                    if (this.x + 15 > o.x && this.x - 15 < o.x + o.w &&
                        this.y + 15 > o.y && this.y - 15 < o.y + o.h) {
                        // Push out
                        this.x -= Math.cos(this.angle) * 3;
                        this.y -= Math.sin(this.angle) * 3;
                    }
                }
            }

            respawn() {
                this.alive = true;
                this.x = (this.color === '#00ff00') ? 50 : 750;
                this.y = (this.color === '#00ff00') ? 50 : 550;
            }

            draw() {
                // Draw Bullets
                ctx.fillStyle = '#fff';
                this.bullets.forEach(b => {
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 4, 0, Math.PI*2);
                    ctx.fill();
                });

                if (!this.alive) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Body
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillRect(-15, -15, 30, 30);
                
                // Turret
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, -5, 25, 10);
                
                ctx.restore();
            }
        }

        const p1 = new Tank(50, 50, '#00ff00', { up: 'KeyW', down: 'KeyS', left: 'KeyA', right: 'KeyD', shoot: 'Space' });
        const p2 = new Tank(750, 550, '#00ffff', { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', shoot: 'Enter' });

        function update() {
            p1.update();
            p2.update();

            // Hit detection
            p1.bullets.forEach((b, i) => {
                if (p2.alive && Math.hypot(b.x - p2.x, b.y - p2.y) < 20) {
                    p2.alive = false;
                    p2.respawnTimer = 100;
                    p1.score++;
                    p1.bullets.splice(i, 1);
                }
            });

            p2.bullets.forEach((b, i) => {
                if (p1.alive && Math.hypot(b.x - p1.x, b.y - p1.y) < 20) {
                    p1.alive = false;
                    p1.respawnTimer = 100;
                    p2.score++;
                    p2.bullets.splice(i, 1);
                }
            });
        }

        function draw() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Obstacles
            ctx.fillStyle = '#333';
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            obstacles.forEach(o => {
                ctx.fillRect(o.x, o.y, o.w, o.h);
                ctx.strokeRect(o.x, o.y, o.w, o.h);
            });

            p1.draw();
            p2.draw();

            // Scores
            ctx.fillStyle = '#fff';
            ctx.font = "30px Space Grotesk";
            ctx.fillText(p1.score, 50, 50);
            ctx.fillText(p2.score, 730, 50);
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        loop();

    </script>
</body>
</html>
