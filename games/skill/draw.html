<!DOCTYPE html>
<html>
<head>
    <title>Gravity Brush</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Space Grotesk', sans-serif; }
        canvas { display: block; cursor: crosshair; }
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        button {
            padding: 10px 20px;
            background: #fff;
            border: none;
            border-radius: 20px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        button:hover { opacity: 1; }
        #status {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: transparent;
            color: #aaa;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <button class="back-btn" onclick="location.href='../../index.html'">‚Üê Back</button>

    <div id="ui">
        <button onclick="simulate()" style="background: #00b894;">RUN</button>
        <button onclick="resetBall()" style="background: #fdcb6e;">RESET BALL</button>
        <button onclick="clearLines()" style="background: #d63031;">CLEAR LINES</button>
        <button onclick="newLevel()" style="background: #0984e3;">NEW LEVEL</button>
    </div>

    <div id="status">Draw lines to guide the ball to the GOAL</div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        let width, height;
        
        let start = { x: 100, y: 100, r: 15 };
        let goal = { x: 0, y: 0, r: 25 };
        let ball = { x: 0, y: 0, vx: 0, vy: 0, r: 10, active: false };
        
        let lines = [];
        let isDrawing = false;
        let currentLine = null;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if (!ball.active) resetBall(); // Keep ball at start if not running
        }
        window.addEventListener('resize', resize);

        function newLevel() {
            start.x = 50 + Math.random() * (width * 0.3);
            start.y = 50 + Math.random() * (height * 0.3);
            
            goal.x = width * 0.6 + Math.random() * (width * 0.3);
            goal.y = height * 0.5 + Math.random() * (height * 0.4);
            
            lines = [];
            resetBall();
            statusEl.textContent = "Draw lines to guide the ball";
            statusEl.style.color = "#fff";
        }

        function resetBall() {
            ball.x = start.x;
            ball.y = start.y;
            ball.vx = 0;
            ball.vy = 0;
            ball.active = false;
        }

        function clearLines() {
            lines = [];
            resetBall();
        }

        function simulate() {
            if(ball.active) return;
            resetBall();
            ball.active = true;
        }

        // Input Handling
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            startDraw({ clientX: touch.clientX, clientY: touch.clientY });
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            draw({ clientX: touch.clientX, clientY: touch.clientY });
        });
        canvas.addEventListener('touchend', endDraw);

        function startDraw(e) {
            isDrawing = true;
            currentLine = [{ x: e.clientX, y: e.clientY }];
        }

        function draw(e) {
            if (!isDrawing) return;
            const p = { x: e.clientX, y: e.clientY };
            const last = currentLine[currentLine.length - 1];
            
            // Simple distance check to avoid too many points
            const dist = Math.hypot(p.x - last.x, p.y - last.y);
            if (dist > 5) {
                currentLine.push(p);
            }
        }

        function endDraw() {
            if (!isDrawing) return;
            isDrawing = false;
            if (currentLine.length > 1) {
                lines.push(currentLine);
            }
            currentLine = null;
        }

        // Physics
        function update() {
            if (ball.active) {
                ball.vy += 0.6; // Stronger Gravity
                // ball.vx *= 0.99; // Removed air friction for cleaner feel
                
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Screen Bounds (Reset if off screen)
                if (ball.y > height + 100 || ball.x < -100 || ball.x > width + 100) {
                    ball.active = false;
                    statusEl.textContent = "Fell off! Try again.";
                    setTimeout(resetBall, 1000);
                }

                // Check Goal
                const dGoal = Math.hypot(ball.x - goal.x, ball.y - goal.y);
                if (dGoal < goal.r + ball.r) {
                    ball.active = false;
                    ball.vx = 0; ball.vy = 0;
                    statusEl.textContent = "SUCCESS! Loading new level...";
                    statusEl.style.color = "#00b894";
                    setTimeout(newLevel, 1500);
                }

                // Check Line Collisions
                // Iterate all segments
                for (let line of lines) {
                    for (let i = 0; i < line.length - 1; i++) {
                        const p1 = line[i];
                        const p2 = line[i+1];
                        resolveCollision(p1, p2);
                    }
                }
            }
        }

        function resolveCollision(p1, p2) {
            // Vector from p1 to p2
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const lenSq = dx*dx + dy*dy;
            
            // Project ball onto line segment
            // t = ((ball.x - p1.x) * dx + (ball.y - p1.y) * dy) / lenSq
            let t = ((ball.x - p1.x) * dx + (ball.y - p1.y) * dy) / lenSq;
            t = Math.max(0, Math.min(1, t)); // Clamp to segment

            // Closest point on segment
            const closestX = p1.x + t * dx;
            const closestY = p1.y + t * dy;

            // Vector from closest point to ball
            const distVecX = ball.x - closestX;
            const distVecY = ball.y - closestY;
            const dist = Math.hypot(distVecX, distVecY);

            if (dist < ball.r) {
                // Collision!
                // Normal vector
                const nx = distVecX / dist;
                const ny = distVecY / dist;

                // Push out
                const overlap = ball.r - dist;
                ball.x += nx * overlap;
                ball.y += ny * overlap;

                // Reflect velocity
                // v' = v - 2 * (v . n) * n
                const dot = ball.vx * nx + ball.vy * ny;
                
                // Only reflect if moving towards the wall
                if (dot < 0) {
                    ball.vx = (ball.vx - 2 * dot * nx) * 0.8; // Higher bounciness
                    ball.vy = (ball.vy - 2 * dot * ny) * 0.8;
                }
            }
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Draw Start
            ctx.beginPath();
            ctx.arc(start.x, start.y, start.r, 0, Math.PI*2);
            ctx.fillStyle = '#0984e3';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.fillText("START", start.x - 20, start.y - 20);

            // Draw Goal
            ctx.beginPath();
            ctx.arc(goal.x, goal.y, goal.r, 0, Math.PI*2);
            ctx.fillStyle = '#00b894';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.fillText("GOAL", goal.x - 20, goal.y - 30);

            // Draw Lines
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (let line of lines) {
                if (line.length < 2) continue;
                ctx.beginPath();
                ctx.moveTo(line[0].x, line[0].y);
                for (let i = 1; i < line.length; i++) {
                    ctx.lineTo(line[i].x, line[i].y);
                }
                ctx.stroke();
            }

            // Draw Current Line
            if (isDrawing && currentLine && currentLine.length > 0) {
                ctx.beginPath();
                ctx.moveTo(currentLine[0].x, currentLine[0].y);
                for (let i = 1; i < currentLine.length; i++) {
                    ctx.lineTo(currentLine[i].x, currentLine[i].y);
                }
                ctx.stroke();
            }

            // Draw Ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
            ctx.fillStyle = '#fdcb6e';
            ctx.fill();

            requestAnimationFrame(loop);
        }

        function loop() {
            update();
            render();
        }

        // Init
        resize();
        newLevel();
        loop();

    </script>
</body>
</html>
