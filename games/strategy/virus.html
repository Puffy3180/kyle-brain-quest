<!DOCTYPE html>
<html>
<head>
    <title>Virus Wars</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #2d3436; color: #fff; font-family: 'Space Grotesk', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        .grid { display: grid; gap: 2px; background: #636e72; padding: 2px; }
        .cell { width: 40px; height: 40px; background: #b2bec3; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; transition: 0.1s; user-select: none; }
        .cell:hover { opacity: 0.8; }
        .cell.p1 { background: #00b894; color: #fff; }
        .cell.p2 { background: #d63031; color: #fff; }
        .ui { margin-bottom: 20px; font-size: 1.5rem; display: flex; gap: 40px; }
        .back-btn { position: absolute; top: 20px; right: 20px; color: #aaa; text-decoration: none; }
        #winner { font-size: 2rem; color: #fdcb6e; height: 40px; }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-btn">Exit Sim</a>
    <div id="winner"></div>
    <div class="ui">
        <div style="color: #00b894">Player: <span id="s1">1</span></div>
        <div style="color: #d63031">AI: <span id="s2">1</span></div>
    </div>
    <div class="grid" id="grid"></div>

    <script>
        const GRID_SIZE = 10;
        const gridEl = document.getElementById('grid');
        let grid = [];
        let turn = 1; // 1 = Player, 2 = AI
        let gameOver = false;

        gridEl.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;

        // Init Grid
        for (let y = 0; y < GRID_SIZE; y++) {
            let row = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                let cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                cell.onclick = () => handleClick(x, y);
                gridEl.appendChild(cell);
                row.push({ x, y, owner: 0, el: cell });
            }
            grid.push(row);
        }

        // Start Positions
        grid[0][0].owner = 1; // Top Left P1
        grid[GRID_SIZE-1][GRID_SIZE-1].owner = 2; // Bottom Right AI
        updateView();

        function updateView() {
            let s1 = 0, s2 = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = grid[y][x];
                    cell.el.className = 'cell';
                    if (cell.owner === 1) { cell.el.classList.add('p1'); s1++; }
                    if (cell.owner === 2) { cell.el.classList.add('p2'); s2++; }
                }
            }
            document.getElementById('s1').innerText = s1;
            document.getElementById('s2').innerText = s2;
            
            if (s1 === 0) end(2);
            else if (s2 === 0) end(1);
            else if (s1 + s2 === GRID_SIZE * GRID_SIZE) end(s1 > s2 ? 1 : 2);
        }

        function getNeighbors(x, y) {
            const n = [];
            if (x > 0) n.push(grid[y][x-1]);
            if (x < GRID_SIZE-1) n.push(grid[y][x+1]);
            if (y > 0) n.push(grid[y-1][x]);
            if (y < GRID_SIZE-1) n.push(grid[y+1][x]);
            return n;
        }

        function handleClick(x, y) {
            if (turn !== 1 || gameOver) return;
            
            // Validate Move: Must be neighbor to owned cell AND not owned by self
            const target = grid[y][x];
            if (target.owner === 1) return;

            let valid = false;
            const neighbors = getNeighbors(x, y);
            if (neighbors.some(n => n.owner === 1)) valid = true;

            if (valid) {
                // Capture: Change clicked cell to 1, AND convert all enemy neighbors to 1
                target.owner = 1;
                neighbors.forEach(n => {
                    if (n.owner === 2) n.owner = 1;
                });
                
                updateView();
                turn = 2;
                setTimeout(aiTurn, 500);
            }
        }

        function aiTurn() {
            if (gameOver) return;

            // Simple AI: Find move that maximizes immediate gain
            let bestMove = null;
            let maxGain = -1;

            // Iterate all neutral or enemy cells adjacent to AI cells
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x].owner !== 2) {
                        const neighbors = getNeighbors(x, y);
                        // Must be adjacent to AI
                        if (neighbors.some(n => n.owner === 2)) {
                            // Calculate potential gain (1 for cell + 1 for each enemy neighbor flipped)
                            let gain = 1;
                            neighbors.forEach(n => {
                                if (n.owner === 1) gain++;
                            });

                            if (gain > maxGain) {
                                maxGain = gain;
                                bestMove = { x, y };
                            }
                        }
                    }
                }
            }

            if (bestMove) {
                const target = grid[bestMove.y][bestMove.x];
                target.owner = 2;
                getNeighbors(bestMove.x, bestMove.y).forEach(n => {
                    if (n.owner === 1) n.owner = 2;
                });
                updateView();
                turn = 1;
            } else {
                // No moves possible? (Shouldn't happen unless board full)
                turn = 1;
            }
        }

        function end(winner) {
            gameOver = true;
            document.getElementById('winner').innerText = winner === 1 ? "YOU WIN!" : "AI WINS!";
        }
    </script>
</body>
</html>
